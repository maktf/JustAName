EXTRACREDIT_proj2

Honghao Xu - Weifeng Huang - Yuanhui Yang

func TestDoIterativeFindNode (t *testing.T) {
	Initial all network like a linked list:
	[0] <- [1] <- [2] <- [3] <- [4] <- ... <- [number - 1]

	Given key and value arrays

	For each node to DoIterativeFindNode each node (including itself)

	According to definition, if length of returned node list is equal to 
	constant k, then check whether each node in shortlist is active or 
	inactive by calling time; else if length of returned node list is 
	less than constant k, then check whether any caliing returned node' distance 
	of each node in shortlist to source node is greater than or equal to this
	shortlist' shortest distantce.

	If passing the above possible conditions, this design matchs requirement
}

func TestDoIterativeFindNode (t *testing.T) {
	func TestDoIterativeFindNode (t *testing.T) {
	Initial all network like a linked list:
	[0] <- [1] <- [2] <- [3] <- [4] <- ... <- [number - 1]

	Given key and value arrays

	DoStore function paif of (key, value) in each node in the above network

	DoIterativeStore function to UPDATE paif of (key, updated_value) in each 
	node in the above network

	Compare each node by LocalFindValue function with the above DoIterativeStore 
	function returned nodes to check

	If their NodeId is the same, this design matchs requirement
}

func TestDoIterativeFindValueI (t *testing.T) {
	Initial all network like a linked list:
	[0] <- [1] <- [2] <- [3] <- [4] <- ... <- [number - 1]

	Given key and value arrays

	if DoIterativeFindValue function find the given key, compare the returned value and the given value
	else DoIterativeFindValue Function do not the given key, calculate the distance from key to returned ID
		and if the above distance is less than or equal to the closest distance

	if passing the above possible conditions, this design matchs requirement
}

func TestDoIterativeFindValueII (t *testing.T) {
        Test 1:
	Initial all network like a linked list:
	[0] <- [1] <- [2] <- [3] <- [4] <- ... <- [number - 1]
	
	Test 2:
	Initial network like (a <- b means b pings a):
	[0] <- [1] <- [2] <- [3] <- [4]
	Use [1]'s ID as key, 10 as value, and store this key-value at [4].
	Therefore, when [0] initials a iterativeFindValue to find the above key-value, 
	the call can't find any closer node than [1]. And it will initial FindValue 
	to all the uncontacted nodes in the shortlist. Finally, the value is found and returned.
	
	Test 3:
	Use the same network at Test2. [0] initials a iterativeFindValue to find the key that doesn't exist.
	And it should return a error indicating value isn't found.
}
